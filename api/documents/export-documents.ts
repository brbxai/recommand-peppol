import { Server, type Context } from "@recommand/lib/api";
import { z } from "zod";
import "zod-openapi/extend";
import { zodValidator } from "@recommand/lib/zod-validator";
import { actionFailure } from "@recommand/lib/utils";
import { type AuthenticatedTeamContext, type AuthenticatedUserContext } from "@core/lib/auth-middleware";
import { describeRoute } from "hono-openapi";
import {
    getAllTransmittedDocumentsInRange,
} from "@peppol/data/transmitted-documents";
import {
    describeErrorResponse,
} from "@peppol/utils/api-docs";
import { requireIntegrationSupportedTeamAccess, type CompanyAccessContext } from "@peppol/utils/auth-middleware";
import JSZip from "jszip";
import { renderDocumentPdf } from "@peppol/utils/document-renderer";

const server = new Server();

const exportDocumentsRouteDescription = describeRoute({
    hide: true, // Not exposed as public API yet, we first want to test it internally through UI use
    operationId: "exportDocuments",
    description: "Export all documents within a date range (max 1 month) as a ZIP archive. Supports flat UBL XML format or nested document package structure.",
    summary: "Export Documents",
    tags: ["Documents"],
    responses: {
        "200": {
            description: "Successfully exported documents",
            content: {
                "application/zip": {
                    schema: {
                        type: "string",
                        format: "binary",
                    },
                },
            },
        },
        ...describeErrorResponse(400, "Invalid date range or parameters"),
        ...describeErrorResponse(500, "Failed to export documents"),
    },
});

const exportDocumentsBodySchema = z.object({
    from: z.coerce.date().openapi({
        description: "Start datetime (inclusive). ISO 8601 format.",
        example: "2024-01-01T00:00:00Z",
    }),
    to: z.coerce.date().openapi({
        description: "End datetime (exclusive). ISO 8601 format.",
        example: "2024-01-31T23:59:59Z",
    }),
    outputType: z.enum(["flat", "nested"]).openapi({
        description: "Output format: 'flat' for all XMLs in root, 'nested' for document package structure",
        example: "nested",
    }),
    generatePdf: z.enum(["never", "always", "when_no_pdf_attachment"]).default("never").openapi({
        description: "When to include autogenerated PDF in nested format packages",
        example: "never",
    }),
}).refine((data) => data.to > data.from, {
    message: "End date must be after start date",
    path: ["to"],
}).refine((data) => {
    const maxRange = 31 * 24 * 60 * 60 * 1000;
    const range = data.to.getTime() - data.from.getTime();
    return range <= maxRange;
}, {
    message: "Date range must not exceed 1 month (31 days)",
    path: ["to"],
});

const exportDocumentsParamSchemaWithTeamId = z.object({
    teamId: z.string(),
});

type ExportDocumentsContext = Context<AuthenticatedUserContext & AuthenticatedTeamContext & CompanyAccessContext, string, { in: { param: z.input<typeof exportDocumentsParamSchemaWithTeamId>, json: z.input<typeof exportDocumentsBodySchema> }, out: { param: z.infer<typeof exportDocumentsParamSchemaWithTeamId>, json: z.infer<typeof exportDocumentsBodySchema> } }>;

const _exportDocuments = server.post(
    "/:teamId/documents/export",
    requireIntegrationSupportedTeamAccess(),
    describeRoute({ hide: true }),
    zodValidator("param", exportDocumentsParamSchemaWithTeamId),
    zodValidator("json", exportDocumentsBodySchema),
    _exportDocumentsImplementation,
);

const _exportDocumentsMinimal = server.post(
    "/documents/export",
    requireIntegrationSupportedTeamAccess(),
    exportDocumentsRouteDescription,
    zodValidator("json", exportDocumentsBodySchema),
    _exportDocumentsImplementation,
);

async function _exportDocumentsImplementation(c: ExportDocumentsContext) {
    const { from, to, outputType, generatePdf } = c.req.valid("json");
    const teamId = c.var.team.id;

    try {
        const documents = await getAllTransmittedDocumentsInRange(teamId, from, to);

        if (documents.length === 0) {
            return c.json(actionFailure("No documents found in the specified date range"), 400);
        }

        const zip = new JSZip();

        if (outputType === "flat") {
            for (const document of documents) {
                if (document.xml) {
                    zip.file(`${document.id}.xml`, document.xml);
                }
            }
        } else {
            for (const document of documents) {
                const folder = zip.folder(document.id);
                if (!folder) continue;

                const { xml, ...documentMetadata } = document;
                folder.file("document.json", JSON.stringify(documentMetadata, null, 2));

                if (xml) {
                    folder.file("document.xml", xml);
                }

                let hasPdfAttachment = false;
                if (document.parsed?.attachments) {
                    for (const attachment of document.parsed.attachments) {
                        const base64 = attachment.embeddedDocument;
                        const mimeCode = attachment.mimeCode;
                        const filename = attachment.filename;

                        if (base64 && mimeCode && filename) {
                            folder.file(filename, Buffer.from(base64, 'base64'));
                            if (mimeCode === "application/pdf") {
                                hasPdfAttachment = true;
                            }
                        }
                    }
                }

                const shouldGeneratePdf = generatePdf === "always" || (generatePdf === "when_no_pdf_attachment" && !hasPdfAttachment);

                if (shouldGeneratePdf) {
                    try {
                        const pdfBuffer = await renderDocumentPdf(document);
                        folder.file("auto-generated.pdf", pdfBuffer);
                    } catch (error) {
                        console.error(`Failed to generate PDF for document ${document.id}:`, error);
                    }
                }
            }
        }

        const zipBuffer = await zip.generateAsync({ type: "nodebuffer" });

        const startDate = from.toISOString().replace(/[:.]/g, '-').slice(0, -5);
        const endDate = to.toISOString().replace(/[:.]/g, '-').slice(0, -5);
        const filename = `documents-${startDate}-${endDate}.zip`;
        console.log(filename);

        c.header("Content-Type", "application/zip");
        c.header("Content-Disposition", `attachment; filename="${filename}"`);

        return c.body(zipBuffer);
    } catch (error) {
        console.error("Failed to export documents:", error);
        return c.json(actionFailure("Failed to export documents"), 500);
    }
}

export type ExportDocuments = typeof _exportDocuments | typeof _exportDocumentsMinimal;

export default server;

